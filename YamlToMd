using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace YamlToMarkdown
{
    class Program
    {
        static void Main(string[] args)
        {
            string yamlFilePath = "path_to_your_openapi.yaml"; // Path to your NSwag YAML file
            string markdownOutputPath = "README.md"; // Output path for the generated markdown file

            // Read the YAML file (as text)
            string yamlContent = File.ReadAllText(yamlFilePath);

            // Process the YAML content into a structured object (basic parsing)
            var apiSpec = ParseYamlToDictionary(yamlContent);

            // Create the markdown content
            StringBuilder markdownContent = new StringBuilder();

            // Adding API info
            if (apiSpec.ContainsKey("info"))
            {
                var info = apiSpec["info"] as Dictionary<string, object>;
                markdownContent.AppendLine("# API Documentation");
                markdownContent.AppendLine();
                markdownContent.AppendLine("## API Info");
                markdownContent.AppendLine($"**Title:** {info["title"]}");
                markdownContent.AppendLine($"**Version:** {info["version"]}");
                markdownContent.AppendLine($"**Description:** {info["description"]}");
                markdownContent.AppendLine();
            }

            // Process paths (endpoints)
            if (apiSpec.ContainsKey("paths"))
            {
                var paths = apiSpec["paths"] as Dictionary<string, object>;
                markdownContent.AppendLine("## Endpoints");
                foreach (var path in paths)
                {
                    string pathUrl = path.Key;
                    markdownContent.AppendLine($"### {pathUrl}");

                    var operations = path.Value as Dictionary<string, object>;
                    foreach (var operation in operations)
                    {
                        string method = operation.Key.ToUpper(); // GET, POST, etc.
                        var operationDetails = operation.Value as Dictionary<string, object>;

                        markdownContent.AppendLine($"- **Method**: {method}");

                        if (operationDetails.ContainsKey("summary"))
                        {
                            markdownContent.AppendLine($"  - **Summary**: {operationDetails["summary"]}");
                        }

                        // Process parameters
                        if (operationDetails.ContainsKey("parameters"))
                        {
                            markdownContent.AppendLine("  - **Parameters**:");
                            var parameters = operationDetails["parameters"] as List<object>;
                            foreach (var param in parameters)
                            {
                                var paramDict = param as Dictionary<string, object>;
                                markdownContent.AppendLine($"    - **{paramDict["name"]}**: {paramDict["description"] ?? "No description"} (Type: {paramDict["type"]})");
                            }
                        }

                        // Process responses
                        if (operationDetails.ContainsKey("responses"))
                        {
                            markdownContent.AppendLine("  - **Responses**:");
                            var responses = operationDetails["responses"] as Dictionary<string, object>;
                            foreach (var response in responses)
                            {
                                var responseDetails = response.Value as Dictionary<string, object>;
                                markdownContent.AppendLine($"    - **{response.Key}**: {responseDetails["description"] ?? "No description"}");
                            }
                        }
                    }
                }
            }

            // Write the markdown to a file
            File.WriteAllText(markdownOutputPath, markdownContent.ToString());
            Console.WriteLine("README.md has been generated!");
        }

        // Parse YAML by spaces to detect levels and build nested dictionaries
        static Dictionary<string, object> ParseYamlToDictionary(string yamlContent)
        {
            var result = new Dictionary<string, object>();
            var lines = yamlContent.Split(new[] { '\n' }, StringSplitOptions.RemoveEmptyEntries);
            var stack = new Stack<Dictionary<string, object>>(); // Stack to handle nested structures
            stack.Push(result); // Push the root level dictionary onto the stack

            string currentKey = null;
            int currentLevel = 0;

            foreach (var line in lines)
            {
                string trimmedLine = line.Trim();
                if (string.IsNullOrEmpty(trimmedLine)) continue;

                int indentLevel = line.Length - trimmedLine.Length; // Calculate indentation level (number of spaces)
                if (indentLevel > currentLevel)
                {
                    // We're going deeper into a nested structure
                    var newDict = new Dictionary<string, object>();
                    stack.Peek()[currentKey] = newDict;
                    stack.Push(newDict);
                }
                else if (indentLevel < currentLevel)
                {
                    // We're going up in the structure
                    for (int i = 0; i < currentLevel - indentLevel; i++)
                    {
                        stack.Pop(); // Pop the stack to go up a level
                    }
                }

                if (trimmedLine.Contains(":"))
                {
                    // Key-value pair detected (or array element)
                    var parts = trimmedLine.Split(new[] { ':' }, 2);
                    currentKey = parts[0].Trim();
                    var value = parts.Length > 1 ? parts[1].Trim() : null;

                    if (value == null)
                    {
                        // Empty value, which means it's likely going to hold nested data (like a list or object)
                        stack.Peek()[currentKey] = new List<object>();
                    }
                    else
                    {
                        // Normal key-value assignment
                        stack.Peek()[currentKey] = value;
                    }
                }
                else
                {
                    // Handle list item (e.g., "- item" in YAML)
                    stack.Peek()[currentKey] = stack.Peek()[currentKey] ?? new List<object>();
                    (stack.Peek()[currentKey] as List<object>)?.Add(trimmedLine);
                }

                // Update current level
                currentLevel = indentLevel;
            }

            return result;
        }
    }
}
